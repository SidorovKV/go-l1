1. Какой самый эффективный способ конкатенации строк?

```
Из стандартных средств Go - 
out := &strings.Builder{}
out.WriteRune(s1)
out.WriteRune(s2)
....
out.WriteRune(sn)
out.String()
```

2. Что такое интерфейсы, как они применяются в Go?
```
Типы, описывающие поведение. Применяются для реализации полиморфизма и IoC.
```

3. Чем отличаются RWMutex от Mutex?

```
Mutex эксклюзивно лочить ресурс в рутине и на запись, и на чтение.
RWMutex позволяет так же эксклюзивно лочить и на запись, и на чтение,
либо лочить только на запись, позволяя читать ресурс из других рутин.
```

4. Чем отличаются буферизированные и не буферизированные каналы?

```
Буферизированные позволяют писать в них, пока буфер не заполнится,
затем рутина будет ждать, пока из канала не прочтётся хотя бы одно значение.
Небуферизированный канал после записи одного значения будет ожидать,
пока это значение не вычитают, не давая писать в канал.
```

5. Какой размер у структуры struct{}{}?

```
Без учёта накладных расходов общих для любых структур,
такая структура занимает 0 байт.
```


6. Есть ли в Go перегрузка методов или операторов?

```
Нет.
```


7. В какой последовательности будут выведены элементы map[int]int?

Пример:
m[0]=1
m[1]=124
m[2]=281

```
В случайном, если не перебирать ключи по порядку.
```

8. В чем разница make и new?

```
make - для мап, массивов, слайсов. Возвращает значение.
new - для любых структур. Возвращает указатель
```

9. Сколько существует способов задать переменную типа slice или map?
```go
var slice []type 
slice := []type{}
slice := []type{val1, val2, val3}

array := [5]type{}
slice := array[:]

slice := make([]type, 0)
slice := make([]type, 0, 5)
slice := new([]int)

var m map[comparable]type // not initialized
m := make(map[comparable]type)
m := map[comparable]type{key: value, key2: value2}
```

10. Что выведет данная программа и почему?

```go
func update(p *int) {
    b := 2
    p = &b
}

func main() {
var (
    a = 1
    p = &a
)
    fmt.Println(*p)
    update(p)
    fmt.Println(*p)
}
```

```
1
1

Мы передали в функцию указатель(копию) на значение, затем во внутреннем скоупе функции положили
во внутреннюю переменную функции другой указатель. Из функции ничего не возвращается,
в основном скоупе ничего не изменилось.
```

11. Что выведет данная программа и почему?

```go
func main() {
    wg := sync.WaitGroup{}
    for i := 0; i < 5; i++ {
        wg.Add(1)
        go func(wg sync.WaitGroup, i int) {
            fmt.Println(i)
            wg.Done()
        }(wg, i)
    }
    wg.Wait()
    fmt.Println("exit")
}
```

```
Выведет числа в столбик от 0 до 4 в случайном порядке и deadlock.
Порядок зависит от настроения планировщика. deadlock из-за передачи копии вэйт-группы, а не указателя.
```

12. Что выведет данная программа и почему?

```go
func main() {
    n := 0
    if true {
        n := 1
        n++
    }
    fmt.Println(n)
}
```
```
0

n переопределена в скоупе условной операции.
```

13. Что выведет данная программа и почему?

```go
func someAction(v []int8, b int8) {
    v[0] = 100
    v = append(v, b)
}
    
func main() {
    var a = []int8{1, 2, 3, 4, 5}
    someAction(a, 6)
    fmt.Println(a)
}
```

```
[100 2 3 4 5]

Первым действием someAction меняет первый элемент базового массива,
вторым действием, расширяя слайс, создаёт новый, но не возвращает новый слайс из ф-ии
```

14. Что выведет данная программа и почему?

```go
func main() {
    slice := []string{"a", "a"}
    
    func(slice []string) {
        slice = append(slice, "a")
        slice[0] = "b"
        slice[1] = "b"
        fmt.Print(slice)
    }(slice)
    fmt.Print(slice)
}
```

```
[b b a][a a]

В функции расширили слайс, создав новый базовый массив под него. 
Поэтому первые базовый массив и слайс не изменились.
```
